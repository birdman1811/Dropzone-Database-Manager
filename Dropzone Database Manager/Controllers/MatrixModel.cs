using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dropzone_Database_Manager.Controllers
{
    // <auto-generated />
    //
    // To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
    //
    //    using QuickType;
    //
    //    var units = Units.FromJson(jsonString);



    public partial class Units
    {
        [JsonProperty("total_rows")]
        public long TotalRows { get; set; }

        [JsonProperty("offset")]
        public long Offset { get; set; }

        [JsonProperty("rows")]
        public List<Row> Rows { get; set; }
    }

    public partial class Row
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("key")]
        public string Key { get; set; }

        [JsonProperty("value")]
        public long Value { get; set; }

        [JsonProperty("doc")]
        public Doc Doc { get; set; }
    }

    public partial class Doc
    {
        [JsonProperty("_id")]
        public string DocId { get; set; }

        [JsonProperty("_rev")]
        public string Rev { get; set; }

        [JsonProperty("Id")]
        public string Id { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Armour")]
        public long Armour { get; set; }

        [JsonProperty("Move")]
        public long Move { get; set; }

        [JsonProperty("CounterMeasures")]
        public List<CounterMeasure> CounterMeasures { get; set; }

        [JsonProperty("DamagePoints")]
        public long DamagePoints { get; set; }

        [JsonProperty("Points")]
        public long Points { get; set; }

        [JsonProperty("Type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("Category")]
        public Category Category { get; set; }

        [JsonProperty("Cqb")]
        public Cqb Cqb { get; set; }

        [JsonProperty("Fortitude")]
        public long Fortitude { get; set; }

        [JsonProperty("SquadSizeCoherancy")]
        public List<string> SquadSizeCoherancy { get; set; }

        [JsonProperty("LandingZone")]
        public LandingZone? LandingZone { get; set; }

        [JsonProperty("TransportOptions")]
        public List<string> TransportOptions { get; set; }

        [JsonProperty("ExtraRules")]
        public List<string> ExtraRules { get; set; }

        [JsonProperty("Special")]
        public List<string> Special { get; set; }

        [JsonProperty("Weapons")]
        public List<Weapon> Weapons { get; set; }

        [JsonProperty("Faction")]
        public Faction? Faction { get; set; }
    }

    public partial class Weapon
    {
        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Energy")]
        public long Energy { get; set; }

        [JsonProperty("Shots")]
        public long Shots { get; set; }

        [JsonProperty("Accuracy")]
        public long Accuracy { get; set; }

        [JsonProperty("RangeFull")]
        public Range? RangeFull { get; set; }

        [JsonProperty("RangeCountered")]
        public RangeCountered RangeCountered { get; set; }

        [JsonProperty("MoveFire")]
        public MoveFireUnion MoveFire { get; set; }

        [JsonProperty("Arc")]
        public Arc? Arc { get; set; }

        [JsonProperty("Optional")]
        public bool Optional { get; set; }

        [JsonProperty("OptionalCost")]
        public long OptionalCost { get; set; }

        [JsonProperty("Special")]
        public List<string> Special { get; set; }

        [JsonProperty("FullString")]
        public string FullString { get; set; }
    }

    public enum Category { Airstrike, Command, Drill, Empty, Exotic, Gate, Grasping, Heavy, Scout, Standard, Support, Transport, Troops };

    public enum CounterMeasure { A, CounterMeasureA, CounterMeasureE3, CounterMeasureP4, E1, E2, E3, Empty, NA, P3, P4, P5, P6, S };

    public enum Faction { Phr, Resistance, Scourge, Shaltari, Ucm };

    public enum LandingZone { L, M, S, Tiny };

    public enum TypeEnum { Aircraft, Infantry, Vehicle };

    public enum Arc { ArcF, ArcFSLeft, ArcFSRight, Empty, F, FN, FS, FSLeft, FSR, FSRLeft, FSRRight, FSRighr, FSRight, N, R };

    public enum MoveFireEnum { Empty, NA, The0, The1, The10, The12, The2, The3, The4, The6, The8, The9 };

    public enum Range { Cc, Empty, NA, Range, The1, The12, The18, The21, The24, The3, The30, The36, The4, The48, The6, The9 };

    public partial struct Cqb
    {
        public double? Double;
        public string String;

        public static implicit operator Cqb(double Double) => new Cqb { Double = Double };
        public static implicit operator Cqb(string String) => new Cqb { String = String };
    }

    public partial struct MoveFireUnion
    {
        public MoveFireEnum? Enum;
        public long? Integer;

        public static implicit operator MoveFireUnion(MoveFireEnum Enum) => new MoveFireUnion { Enum = Enum };
        public static implicit operator MoveFireUnion(long Integer) => new MoveFireUnion { Integer = Integer };
        public bool IsNull => Integer == null && Enum == null;
    }

    public partial struct RangeCountered
    {
        public Range? Enum;
        public long? Integer;

        public static implicit operator RangeCountered(Range Enum) => new RangeCountered { Enum = Enum };
        public static implicit operator RangeCountered(long Integer) => new RangeCountered { Integer = Integer };
        public bool IsNull => Integer == null && Enum == null;
    }

    public partial class Units
    {
        public static Units FromJson(string json) => JsonConvert.DeserializeObject<Units>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Units self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CategoryConverter.Singleton,
                CounterMeasureConverter.Singleton,
                CqbConverter.Singleton,
                FactionConverter.Singleton,
                LandingZoneConverter.Singleton,
                TypeEnumConverter.Singleton,
                ArcConverter.Singleton,
                MoveFireUnionConverter.Singleton,
                MoveFireEnumConverter.Singleton,
                RangeCounteredConverter.Singleton,
                RangeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CategoryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Category) || t == typeof(Category?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "*":
                    return Category.Empty;
                case "Airstrike":
                    return Category.Airstrike;
                case "Command":
                    return Category.Command;
                case "Drill":
                    return Category.Drill;
                case "Exotic":
                    return Category.Exotic;
                case "Gate":
                    return Category.Gate;
                case "Grasping*":
                    return Category.Grasping;
                case "Heavy":
                    return Category.Heavy;
                case "Scout":
                    return Category.Scout;
                case "Standard":
                    return Category.Standard;
                case "Support":
                    return Category.Support;
                case "Transport":
                    return Category.Transport;
                case "Troops":
                    return Category.Troops;
            }
            throw new Exception("Cannot unmarshal type Category");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Category)untypedValue;
            switch (value)
            {
                case Category.Empty:
                    serializer.Serialize(writer, "*");
                    return;
                case Category.Airstrike:
                    serializer.Serialize(writer, "Airstrike");
                    return;
                case Category.Command:
                    serializer.Serialize(writer, "Command");
                    return;
                case Category.Drill:
                    serializer.Serialize(writer, "Drill");
                    return;
                case Category.Exotic:
                    serializer.Serialize(writer, "Exotic");
                    return;
                case Category.Gate:
                    serializer.Serialize(writer, "Gate");
                    return;
                case Category.Grasping:
                    serializer.Serialize(writer, "Grasping*");
                    return;
                case Category.Heavy:
                    serializer.Serialize(writer, "Heavy");
                    return;
                case Category.Scout:
                    serializer.Serialize(writer, "Scout");
                    return;
                case Category.Standard:
                    serializer.Serialize(writer, "Standard");
                    return;
                case Category.Support:
                    serializer.Serialize(writer, "Support");
                    return;
                case Category.Transport:
                    serializer.Serialize(writer, "Transport");
                    return;
                case Category.Troops:
                    serializer.Serialize(writer, "Troops");
                    return;
            }
            throw new Exception("Cannot marshal type Category");
        }

        public static readonly CategoryConverter Singleton = new CategoryConverter();
    }

    internal class CounterMeasureConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CounterMeasure) || t == typeof(CounterMeasure?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "-":
                    return CounterMeasure.Empty;
                case "A":
                    return CounterMeasure.A;
                case "A*":
                    return CounterMeasure.CounterMeasureA;
                case "E+1":
                    return CounterMeasure.E1;
                case "E+2":
                    return CounterMeasure.E2;
                case "E+3":
                    return CounterMeasure.E3;
                case "E+3*":
                    return CounterMeasure.CounterMeasureE3;
                case "N/A":
                    return CounterMeasure.NA;
                case "P3+":
                    return CounterMeasure.P3;
                case "P4+":
                    return CounterMeasure.CounterMeasureP4;
                case "P4+*":
                    return CounterMeasure.P4;
                case "P5+":
                    return CounterMeasure.P5;
                case "P6+":
                    return CounterMeasure.P6;
                case "S":
                    return CounterMeasure.S;
            }
            throw new Exception("Cannot unmarshal type CounterMeasure");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CounterMeasure)untypedValue;
            switch (value)
            {
                case CounterMeasure.Empty:
                    serializer.Serialize(writer, "-");
                    return;
                case CounterMeasure.A:
                    serializer.Serialize(writer, "A");
                    return;
                case CounterMeasure.CounterMeasureA:
                    serializer.Serialize(writer, "A*");
                    return;
                case CounterMeasure.E1:
                    serializer.Serialize(writer, "E+1");
                    return;
                case CounterMeasure.E2:
                    serializer.Serialize(writer, "E+2");
                    return;
                case CounterMeasure.E3:
                    serializer.Serialize(writer, "E+3");
                    return;
                case CounterMeasure.CounterMeasureE3:
                    serializer.Serialize(writer, "E+3*");
                    return;
                case CounterMeasure.NA:
                    serializer.Serialize(writer, "N/A");
                    return;
                case CounterMeasure.P3:
                    serializer.Serialize(writer, "P3+");
                    return;
                case CounterMeasure.CounterMeasureP4:
                    serializer.Serialize(writer, "P4+");
                    return;
                case CounterMeasure.P4:
                    serializer.Serialize(writer, "P4+*");
                    return;
                case CounterMeasure.P5:
                    serializer.Serialize(writer, "P5+");
                    return;
                case CounterMeasure.P6:
                    serializer.Serialize(writer, "P6+");
                    return;
                case CounterMeasure.S:
                    serializer.Serialize(writer, "S");
                    return;
            }
            throw new Exception("Cannot marshal type CounterMeasure");
        }

        public static readonly CounterMeasureConverter Singleton = new CounterMeasureConverter();
    }

    internal class CqbConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Cqb) || t == typeof(Cqb?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Cqb { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Cqb { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Cqb");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Cqb)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Cqb");
        }

        public static readonly CqbConverter Singleton = new CqbConverter();
    }

    internal class FactionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Faction) || t == typeof(Faction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "PHR":
                    return Faction.Phr;
                case "Resistance":
                    return Faction.Resistance;
                case "Scourge":
                    return Faction.Scourge;
                case "Shaltari":
                    return Faction.Shaltari;
                case "UCM":
                    return Faction.Ucm;
            }
            throw new Exception("Cannot unmarshal type Faction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Faction)untypedValue;
            switch (value)
            {
                case Faction.Phr:
                    serializer.Serialize(writer, "PHR");
                    return;
                case Faction.Resistance:
                    serializer.Serialize(writer, "Resistance");
                    return;
                case Faction.Scourge:
                    serializer.Serialize(writer, "Scourge");
                    return;
                case Faction.Shaltari:
                    serializer.Serialize(writer, "Shaltari");
                    return;
                case Faction.Ucm:
                    serializer.Serialize(writer, "UCM");
                    return;
            }
            throw new Exception("Cannot marshal type Faction");
        }

        public static readonly FactionConverter Singleton = new FactionConverter();
    }

    internal class LandingZoneConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LandingZone) || t == typeof(LandingZone?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "L":
                    return LandingZone.L;
                case "M":
                    return LandingZone.M;
                case "S":
                    return LandingZone.S;
                case "Tiny":
                    return LandingZone.Tiny;
            }
            throw new Exception("Cannot unmarshal type LandingZone");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LandingZone)untypedValue;
            switch (value)
            {
                case LandingZone.L:
                    serializer.Serialize(writer, "L");
                    return;
                case LandingZone.M:
                    serializer.Serialize(writer, "M");
                    return;
                case LandingZone.S:
                    serializer.Serialize(writer, "S");
                    return;
                case LandingZone.Tiny:
                    serializer.Serialize(writer, "Tiny");
                    return;
            }
            throw new Exception("Cannot marshal type LandingZone");
        }

        public static readonly LandingZoneConverter Singleton = new LandingZoneConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Aircraft":
                    return TypeEnum.Aircraft;
                case "Infantry":
                    return TypeEnum.Infantry;
                case "Vehicle":
                    return TypeEnum.Vehicle;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Aircraft:
                    serializer.Serialize(writer, "Aircraft");
                    return;
                case TypeEnum.Infantry:
                    serializer.Serialize(writer, "Infantry");
                    return;
                case TypeEnum.Vehicle:
                    serializer.Serialize(writer, "Vehicle");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class ArcConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Arc) || t == typeof(Arc?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "*":
                    return Arc.Empty;
                case "F":
                    return Arc.F;
                case "F(N)":
                    return Arc.FN;
                case "F/S":
                    return Arc.FS;
                case "F/S (Left)":
                    return Arc.ArcFSLeft;
                case "F/S (Righr)":
                    return Arc.FSRighr;
                case "F/S (Right)":
                    return Arc.ArcFSRight;
                case "F/S(Left)":
                    return Arc.FSLeft;
                case "F/S(Right)":
                    return Arc.FSRight;
                case "F/S/R":
                    return Arc.FSR;
                case "F/S/R(Left)":
                    return Arc.FSRLeft;
                case "F/S/R(Right)":
                    return Arc.FSRRight;
                case "N":
                    return Arc.N;
                case "R":
                    return Arc.R;
                case "f":
                    return Arc.ArcF;
            }
            throw new Exception("Cannot unmarshal type Arc");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Arc)untypedValue;
            switch (value)
            {
                case Arc.Empty:
                    serializer.Serialize(writer, "*");
                    return;
                case Arc.F:
                    serializer.Serialize(writer, "F");
                    return;
                case Arc.FN:
                    serializer.Serialize(writer, "F(N)");
                    return;
                case Arc.FS:
                    serializer.Serialize(writer, "F/S");
                    return;
                case Arc.ArcFSLeft:
                    serializer.Serialize(writer, "F/S (Left)");
                    return;
                case Arc.FSRighr:
                    serializer.Serialize(writer, "F/S (Righr)");
                    return;
                case Arc.ArcFSRight:
                    serializer.Serialize(writer, "F/S (Right)");
                    return;
                case Arc.FSLeft:
                    serializer.Serialize(writer, "F/S(Left)");
                    return;
                case Arc.FSRight:
                    serializer.Serialize(writer, "F/S(Right)");
                    return;
                case Arc.FSR:
                    serializer.Serialize(writer, "F/S/R");
                    return;
                case Arc.FSRLeft:
                    serializer.Serialize(writer, "F/S/R(Left)");
                    return;
                case Arc.FSRRight:
                    serializer.Serialize(writer, "F/S/R(Right)");
                    return;
                case Arc.N:
                    serializer.Serialize(writer, "N");
                    return;
                case Arc.R:
                    serializer.Serialize(writer, "R");
                    return;
                case Arc.ArcF:
                    serializer.Serialize(writer, "f");
                    return;
            }
            throw new Exception("Cannot marshal type Arc");
        }

        public static readonly ArcConverter Singleton = new ArcConverter();
    }

    internal class MoveFireUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MoveFireUnion) || t == typeof(MoveFireUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new MoveFireUnion { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new MoveFireUnion { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "-":
                            return new MoveFireUnion { Enum = MoveFireEnum.Empty };
                        case "0\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The0 };
                        case "1\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The1 };
                        case "10\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The10 };
                        case "12\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The12 };
                        case "2\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The2 };
                        case "3\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The3 };
                        case "4\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The4 };
                        case "6\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The6 };
                        case "8\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The8 };
                        case "9\"":
                            return new MoveFireUnion { Enum = MoveFireEnum.The9 };
                        case "N/A":
                            return new MoveFireUnion { Enum = MoveFireEnum.NA };
                    }
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return new MoveFireUnion { Integer = l };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type MoveFireUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (MoveFireUnion)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case MoveFireEnum.Empty:
                        serializer.Serialize(writer, "-");
                        return;
                    case MoveFireEnum.The0:
                        serializer.Serialize(writer, "0\"");
                        return;
                    case MoveFireEnum.The1:
                        serializer.Serialize(writer, "1\"");
                        return;
                    case MoveFireEnum.The10:
                        serializer.Serialize(writer, "10\"");
                        return;
                    case MoveFireEnum.The12:
                        serializer.Serialize(writer, "12\"");
                        return;
                    case MoveFireEnum.The2:
                        serializer.Serialize(writer, "2\"");
                        return;
                    case MoveFireEnum.The3:
                        serializer.Serialize(writer, "3\"");
                        return;
                    case MoveFireEnum.The4:
                        serializer.Serialize(writer, "4\"");
                        return;
                    case MoveFireEnum.The6:
                        serializer.Serialize(writer, "6\"");
                        return;
                    case MoveFireEnum.The8:
                        serializer.Serialize(writer, "8\"");
                        return;
                    case MoveFireEnum.The9:
                        serializer.Serialize(writer, "9\"");
                        return;
                    case MoveFireEnum.NA:
                        serializer.Serialize(writer, "N/A");
                        return;
                }
            }
            throw new Exception("Cannot marshal type MoveFireUnion");
        }

        public static readonly MoveFireUnionConverter Singleton = new MoveFireUnionConverter();
    }

    internal class MoveFireEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MoveFireEnum) || t == typeof(MoveFireEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "-":
                    return MoveFireEnum.Empty;
                case "0\"":
                    return MoveFireEnum.The0;
                case "1\"":
                    return MoveFireEnum.The1;
                case "10\"":
                    return MoveFireEnum.The10;
                case "12\"":
                    return MoveFireEnum.The12;
                case "2\"":
                    return MoveFireEnum.The2;
                case "3\"":
                    return MoveFireEnum.The3;
                case "4\"":
                    return MoveFireEnum.The4;
                case "6\"":
                    return MoveFireEnum.The6;
                case "8\"":
                    return MoveFireEnum.The8;
                case "9\"":
                    return MoveFireEnum.The9;
                case "N/A":
                    return MoveFireEnum.NA;
            }
            throw new Exception("Cannot unmarshal type MoveFireEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MoveFireEnum)untypedValue;
            switch (value)
            {
                case MoveFireEnum.Empty:
                    serializer.Serialize(writer, "-");
                    return;
                case MoveFireEnum.The0:
                    serializer.Serialize(writer, "0\"");
                    return;
                case MoveFireEnum.The1:
                    serializer.Serialize(writer, "1\"");
                    return;
                case MoveFireEnum.The10:
                    serializer.Serialize(writer, "10\"");
                    return;
                case MoveFireEnum.The12:
                    serializer.Serialize(writer, "12\"");
                    return;
                case MoveFireEnum.The2:
                    serializer.Serialize(writer, "2\"");
                    return;
                case MoveFireEnum.The3:
                    serializer.Serialize(writer, "3\"");
                    return;
                case MoveFireEnum.The4:
                    serializer.Serialize(writer, "4\"");
                    return;
                case MoveFireEnum.The6:
                    serializer.Serialize(writer, "6\"");
                    return;
                case MoveFireEnum.The8:
                    serializer.Serialize(writer, "8\"");
                    return;
                case MoveFireEnum.The9:
                    serializer.Serialize(writer, "9\"");
                    return;
                case MoveFireEnum.NA:
                    serializer.Serialize(writer, "N/A");
                    return;
            }
            throw new Exception("Cannot marshal type MoveFireEnum");
        }

        public static readonly MoveFireEnumConverter Singleton = new MoveFireEnumConverter();
    }

    internal class RangeCounteredConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RangeCountered) || t == typeof(RangeCountered?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new RangeCountered { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "*":
                            return new RangeCountered { Enum = Range.Range };
                        case "1\"":
                            return new RangeCountered { Enum = Range.The1 };
                        case "12\"":
                            return new RangeCountered { Enum = Range.The12 };
                        case "18\"":
                            return new RangeCountered { Enum = Range.The18 };
                        case "21\"":
                            return new RangeCountered { Enum = Range.The21 };
                        case "24\"":
                            return new RangeCountered { Enum = Range.The24 };
                        case "3\"":
                            return new RangeCountered { Enum = Range.The3 };
                        case "30\"":
                            return new RangeCountered { Enum = Range.The30 };
                        case "36\"":
                            return new RangeCountered { Enum = Range.The36 };
                        case "4\"":
                            return new RangeCountered { Enum = Range.The4 };
                        case "48\"":
                            return new RangeCountered { Enum = Range.The48 };
                        case "6\"":
                            return new RangeCountered { Enum = Range.The6 };
                        case "9\"":
                            return new RangeCountered { Enum = Range.The9 };
                        case "CC":
                            return new RangeCountered { Enum = Range.Cc };
                        case "N/A":
                            return new RangeCountered { Enum = Range.NA };
                        case "∞":
                            return new RangeCountered { Enum = Range.Empty };
                    }
                    long l;
                    if (Int64.TryParse(stringValue, out l))
                    {
                        return new RangeCountered { Integer = l };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type RangeCountered");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RangeCountered)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case Range.Range:
                        serializer.Serialize(writer, "*");
                        return;
                    case Range.The1:
                        serializer.Serialize(writer, "1\"");
                        return;
                    case Range.The12:
                        serializer.Serialize(writer, "12\"");
                        return;
                    case Range.The18:
                        serializer.Serialize(writer, "18\"");
                        return;
                    case Range.The21:
                        serializer.Serialize(writer, "21\"");
                        return;
                    case Range.The24:
                        serializer.Serialize(writer, "24\"");
                        return;
                    case Range.The3:
                        serializer.Serialize(writer, "3\"");
                        return;
                    case Range.The30:
                        serializer.Serialize(writer, "30\"");
                        return;
                    case Range.The36:
                        serializer.Serialize(writer, "36\"");
                        return;
                    case Range.The4:
                        serializer.Serialize(writer, "4\"");
                        return;
                    case Range.The48:
                        serializer.Serialize(writer, "48\"");
                        return;
                    case Range.The6:
                        serializer.Serialize(writer, "6\"");
                        return;
                    case Range.The9:
                        serializer.Serialize(writer, "9\"");
                        return;
                    case Range.Cc:
                        serializer.Serialize(writer, "CC");
                        return;
                    case Range.NA:
                        serializer.Serialize(writer, "N/A");
                        return;
                    case Range.Empty:
                        serializer.Serialize(writer, "∞");
                        return;
                }
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value.ToString());
                return;
            }
            throw new Exception("Cannot marshal type RangeCountered");
        }

        public static readonly RangeCounteredConverter Singleton = new RangeCounteredConverter();
    }

    internal class RangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Range) || t == typeof(Range?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "*":
                    return Range.Range;
                case "1\"":
                    return Range.The1;
                case "12\"":
                    return Range.The12;
                case "18\"":
                    return Range.The18;
                case "21\"":
                    return Range.The21;
                case "24\"":
                    return Range.The24;
                case "3\"":
                    return Range.The3;
                case "30\"":
                    return Range.The30;
                case "36\"":
                    return Range.The36;
                case "4\"":
                    return Range.The4;
                case "48\"":
                    return Range.The48;
                case "6\"":
                    return Range.The6;
                case "9\"":
                    return Range.The9;
                case "CC":
                    return Range.Cc;
                case "N/A":
                    return Range.NA;
                case "∞":
                    return Range.Empty;
            }
            throw new Exception("Cannot unmarshal type Range");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Range)untypedValue;
            switch (value)
            {
                case Range.Range:
                    serializer.Serialize(writer, "*");
                    return;
                case Range.The1:
                    serializer.Serialize(writer, "1\"");
                    return;
                case Range.The12:
                    serializer.Serialize(writer, "12\"");
                    return;
                case Range.The18:
                    serializer.Serialize(writer, "18\"");
                    return;
                case Range.The21:
                    serializer.Serialize(writer, "21\"");
                    return;
                case Range.The24:
                    serializer.Serialize(writer, "24\"");
                    return;
                case Range.The3:
                    serializer.Serialize(writer, "3\"");
                    return;
                case Range.The30:
                    serializer.Serialize(writer, "30\"");
                    return;
                case Range.The36:
                    serializer.Serialize(writer, "36\"");
                    return;
                case Range.The4:
                    serializer.Serialize(writer, "4\"");
                    return;
                case Range.The48:
                    serializer.Serialize(writer, "48\"");
                    return;
                case Range.The6:
                    serializer.Serialize(writer, "6\"");
                    return;
                case Range.The9:
                    serializer.Serialize(writer, "9\"");
                    return;
                case Range.Cc:
                    serializer.Serialize(writer, "CC");
                    return;
                case Range.NA:
                    serializer.Serialize(writer, "N/A");
                    return;
                case Range.Empty:
                    serializer.Serialize(writer, "∞");
                    return;
            }
            throw new Exception("Cannot marshal type Range");
        }

        public static readonly RangeConverter Singleton = new RangeConverter();
    }
}

